//
//  Node.h
//  HarmonicMotion
//
//  Created by Tim Murray-Browne on 25/09/2013.
//  Copyright (c) 2013 Tim Murray-Browne. All rights reserved.
//

#pragma once

#include "Data.h"
#include <boost/thread/thread.hpp>
#include <atomic>
#include <set>
#include <string>
#include "Common.h"
#include "Parameter.h"
#include "json/json.h"
#include "EventDispatcher.h"

namespace hm
{
	class Node
	{
	public:
		/// Universal instance settings for all nodes. NB Params is not the same
		/// as a Parameter
		struct Params
		{
			/// Name of the node. Will be autogenerated if left blank. All
			/// nodes must have a unique name and name will be adjusted if
			/// necessary to enforce this.
			std::string name;
			/// Specify initial values for parameters. These will only have
			/// effect if the derived node's constructor registers these
			/// parameters and will override the default value specified
			/// there. Any number of parameters may be specified
			/// here (you don't have to specify them all). If the type of
			/// ParameterValueContainer does not match the parameter type
			/// registered under the name then it will be ignored and an
			/// error printed.
			std::map<std::string, ParameterValueContainer> parameterInitialValues;
			/// Location of this node in the GUI
			int guiLocationX;
			int guiLocationY;
			
			Params(std::string const& name_="",
				   std::map<std::string, ParameterValueContainer> const& parameterInitialValues_=std::map<std::string, ParameterValueContainer>())
			: name(name_)
			, parameterInitialValues(parameterInitialValues_)
			, guiLocationX(0)
			, guiLocationY(0)
			{}
			
			virtual ~Params() {}
		};
		
		virtual ~Node();
		std::string className() const { return mClassName; }
		/// The type of the node is a user-friendly name, and also used to
		/// construct nodes from FactoryNode.
		std::string type() const { return mType; }
		/// \return A user-friendly description of what this node does
		std::string description() const { return mDescription; }
		/// \return The unique user-controlled name of this node
		std::string name() const { return nodeParams().name; }
		
		/// The full path to this node, without a trailing slash.
		/// The path is a slash separated string of the parents of this node
		/// followed by the name of this node.
		/// \note At present nodes do not have parents, so this is just "/<name>"
		std::string path() const;
		
		/// If this node is attached to a pipeline then \p name may be modified to
		/// ensure it is unique
		void setName(std::string const& name);
		
		std::string toString() const;
		
		/// Export a Params instance that may be used to reproduce this
		/// object in its current state. This will copy all of the current
		/// parameter values into the initial values of the Params object.
		Params exportParams() const;
		
		/// \param This function may modify \p params to ensure it has
		/// valid values.
		void setNodeParams(Params& params);

		
		int numInlets() const;
		
		/// \return The inlet at index \p index, or nullptr if none exists.
		/// \warning If this node changes its characteristics during runtime
		/// (i.e. adds or removes nodes) then the return of this value should
		/// be checked against \c nullptr event if previously you have tested
		/// that \p index < \c numInlets(). (Due to threading.)
		InletPtr inlet(int index) const;
		std::vector<InletPtr> inlets() const;
		
		int numOutlets() const;
		/// \return The outlet at index \p index, or nullptr if none exists.
		/// \warning If this node changes its characteristics during runtime
		/// (i.e. adds or removes nodes) then the return of this value should
		/// be checked against \c nullptr event if previously you have tested
		/// that \p index < \c numOutlets(). (Due to threading.)
		OutletPtr outlet(int index) const;
		std::vector<OutletPtr> outlets() const;
		
		std::vector<ParameterPtr> parameters();
		std::vector<ParameterConstPtr> parameters() const;
		
		
		
		/// Enabled is a node-specific, user adjustable setting. When disabled,
		/// a node should ignore all input and does not produce new output.
		/// step() will not be called
		virtual void setEnabled(bool isEnabled);
		bool isEnabled() const { return mIsEnabled; }
		
		// Functions called by the owning pipeline
		/// Requests the node prepares to start processing. Override this to
		/// implement code to initialize processing. Call this original function
		/// first.
		virtual void startProcessing();
		
		/// Requests that the node processes one frame of data from its inlets.
		/// Override this function to implement code that performs a single
		/// update.
		/// This function may be called
		/// sequentially from different threads (but not concurrently).
		/// \return true if this node's characteristics have been changed and this
		/// change has not previously caused this function to return true (i.e.
		/// each change should only trigger a true return value one time). False
		/// otherwise.
		virtual bool stepProcessing();
		
		/// Requests that the node stops processing data. Override this function to
		/// implement code that concludes processing. Call this original function
		/// first.
		virtual void stopProcessing();
		
		/// \return true if we are between startProcessing and stopProcessing calls
		/// (even if isEnabled is false)
		bool isProcessing() const { return mIsProcessing; }

		// MARK: Optional functionality
		/// \return True if this Node produces a console (i.e. text) output that may be listened to using addConsoleListener.
		virtual bool hasConsoleOutput() const { return false; }
		/// \return True if the default behaviour of this node is to show the console window (e.g. for a 
		/// printer node). Otherwise if hasConsoleOutput() is true then the console may be considered 
		/// an optional extra.
		virtual bool isConsoleShownByDefault() const { return false;  }
		/// Register a listener to receive console output produced by this node.
		/// A handle is returned that may be used to remove the listener
		/// \warning The callback function may be called from any thread.
		int addConsoleListener(std::function<void(std::string const&)> listenerFunction);
		bool removeConsoleListener(int handle);
		
	protected:
		/// Nodes cannot be directly constructed as they are always
		/// subclassed.
		/// \param className This should the the name of the bottom-most derived
		/// class
		/// \param type A user-friendly name describing this node type
		/// \param description A user-friendly description of what the node
		/// does.
		Node(Params params, std::string className, std::string type, std::string description);
		
		/// Factory function to create new instances of a node. Derived types
		/// must implement this for nodes to be able to be created.
		/// \return A new instance of the derived Node type constructed with
		/// the \p params provided.
		virtual NodePtr create(Params params) const = 0;
		
		/// Create an inlet with the given \p name. This will print an error
		/// and return \c nullptr if \p name is already in use.
		virtual InletPtr createInlet(Types types, std::string const& name, std::string const& description="");
		
		/// Create an outlet with the given \p name. This will print an error
		/// and return \c nullptr if \p name is already in use.
		virtual OutletPtr createOutlet(Types types, std::string const& name, std::string const& description="");
		
		/// Removes an inlet from this node.
		bool removeInlet(InletPtr inlet);
		
		/// Removes an outlet from this node.
		bool removeOutlet(OutletPtr outlet);
		
		/// Create a parameter. A pointer to the parameter is returned which may
		/// be used to customise it.
		/// Parameter effects (callbacks and updates from external sources) only take
		/// effect during a call to updateParameters, which you should do at
		/// the beginning of every step() call (or equivalently frequently if using
		/// NodeThreaded).
		/// The path of the parameter will be the path of the node followed by \p
		/// name.
		/// \note If an initial value for this parameter has been provided through
		/// Node::Params then *value will be set to that during this function. Any
		/// default values for *value should therefore be set before this function
		/// is called.
		/// \param The name of the parameter. This needs to be unique relative to
		/// this node.
		/// \param A pointer to the value that the parameter will be controlling.
		/// \return A shared pointer to the parameter.
		template <typename T>
		ParameterPtrT<T> addParameter(std::string name, T* value, std::string description="");
		
		/// Create a parameter that has already been created. Note that this
		/// will not automatically set the initial value.
		template <typename T>
		ParameterPtrT<T> addParameter(ParameterPtrT<T> parameter);
		
		/// Updates all parameters, activating callbacks where applicable. Callbacks
		/// run in the same thread as this function. This function is called
		/// before step() within NodeUnthreaded. Within NodeThreaded you
		/// will need to call it yourself each time within your update loop.
		/// \note The values associated with the parameters must not be changed
		/// during a call to this function.
		void updateParameters();
		
		/// Output text to any registered console listeners. Note that derived
		/// types using this function should also override \c hasConsoleOutput()
		void outputConsoleText(std::string const& text) const;
		
		
		// MARK: Accessors
		/// \return this node's Params object in its current state.
		Params nodeParams() const;

	private:
		// helper function
		void notifyCharacteristicsChanged();
		
		friend Pipeline;
		/// FUNCTION TO BE ACCESSED BY PIPELINE ONLY.
		void setPipeline(Pipeline* pipeline);
		/////////////////////////////////////
		
		/// The pipeline this node is contained within. This may be nullptr
		/// and should be checked each time it is called.
		/// \warning Nodes must not call functions that modify the pipeline
		/// from their \p stepProcessing() function or any Parameter callbacks
		/// as that might create a deadlock with the pipeline mutex.
		Pipeline* pipeline() const { return mPipeline; }
		/// This may be nullptr and needs to be checked each time.
		EventDispatcherPtr mDispatcher;

		/// We retain a reference to the pipeline. This may be nullptr
		std::atomic<Pipeline*> mPipeline;
		std::vector<InletPtr> mInlets;
		std::vector<OutletPtr> mOutlets;
		std::vector<ParameterPtr> mParameters;
		mutable boost::shared_mutex mParametersMutex;
		Params mNodeParams;
		mutable boost::shared_mutex mNodeParamsMutex;
		/// Guards changes to the characteristics of the node (i.e.
		/// how many inlets and outlets it has)
		mutable boost::shared_mutex mCharacteristicsMutex;
		/// If node characteristics change after start has been called
		/// then this is set to false until we notify the pipeline of the
		/// event.
		std::atomic_flag mHaveAllCharacteristicChangesBeenReported;
		std::atomic<bool> mIsEnabled;
		std::atomic<bool> mIsProcessing;
		std::atomic<bool> mHasStartEverBeenCalled;
//		/// If node characteristics change after start has been called
//		/// then this is set to false until we notify the pipeline of the
//		/// event.
//		std::atomic_flag mHaveAllCharacteristicChangesBeenReported;
		std::string const mClassName;
		std::string const mType;
		std::string const mDescription;

		std::vector<std::pair<int, std::function<void(std::string const&)>>> mConsoleListeners;
		int mNextConsoleListenerHandle;
		mutable boost::mutex mConsoleListenersMutex;

		
		friend Json::Value& operator<<(Json::Value&, Node const&);
		friend bool operator>>(Json::Value const&, Node&);
		
	};
	
	typedef std::function<NodePtr (Node::Params)> NodeCreationFunction;
	
	std::ostream& operator<<(std::ostream&, Node const&);
	
	Json::Value& operator<<(Json::Value&, Node const&);
	bool operator>>(Json::Value const&, Node&);
	
	Json::Value& operator<<(Json::Value&, Node::Params const&);
	bool operator>>(Json::Value const&, Node::Params&);
	
	
	template <typename T>
	ParameterPtrT<T> Node::addParameter(std::string name, T* value, std::string description)
	{
		// Check if we have a custom initial value
		bool hasInitialValue = false;
		T initialValue = T();
		auto parameterInitialValues = nodeParams().parameterInitialValues;
		for (std::pair<std::string,ParameterValueContainer> i: parameterInitialValues)
		{
			if (i.first == name)
			{
				T* t = boost::get<T>(&i.second);
				if (t == nullptr)
				{
					hm_error("Node was constructed with an initial value for "
							 "parameter "+name+" that was of the wrong type.");
				}
				else
				{
					initialValue = *t;
					hasInitialValue = true;
				}
			}
		}
		ParameterPtrT<T> parameter;
		if (hasInitialValue)
		{
			parameter = std::shared_ptr<Parameter<T>>(new Parameter<T>(*this, name, description, value, initialValue));
		}
		else
		{
			parameter = std::shared_ptr<Parameter<T>>(new Parameter<T>(*this, name, description, value));
		}
		return addParameter(parameter);
	}
	
	template <typename T>
	ParameterPtrT<T> Node::addParameter(ParameterPtrT<T> parameter)
	{
		// Parameters may only be registered in the constructor.
		// This is because Pipeline needs to register a callback with
		// them and it does that when the parameter is added to the pipeline
		assert(!mHasStartEverBeenCalled);
		
		boost::lock_guard<boost::shared_mutex> lock(mParametersMutex);
		mParameters.push_back(parameter);
		return parameter;
	}
}



