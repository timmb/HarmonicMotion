//
//  Node.h
//  HarmonicMotion
//
//  Created by Tim Murray-Browne on 25/09/2013.
//  Copyright (c) 2013 Tim Murray-Browne. All rights reserved.
//

#pragma once

#include "Data.h"
#include <boost/thread/thread.hpp>
#include <atomic>
#include <set>
#include <string>
#include "Common.h"
#include "Parameter.h"

namespace hm
{
	class Node
	{
	public:
		/// Universal instance settings for all nodes. NB Params is not the same
		/// as a Parameter
		struct Params
		{
			/// Name of the node. Will be autogenerated if left blank. All
			/// nodes must have a unique name and name will be adjusted if
			/// necessary to enforce this.
			std::string name;
			
			Params(std::string const& name_="")
			: name(name_) {}
			virtual ~Params() {}
		};
		
		virtual ~Node();
		std::string type() const { return mClassName; }
		std::string name() const { return nodeParams().name; }
		/// The full path to this node, without a trailing slash.
		/// The path is a slash separated string of the parents of this node
		/// followed by the name of this node.
		/// \note At present nodes do not have parents, so this is just "/<name>"
		std::string path() const;
		void setName(std::string name);
		std::string toString() const;
				
		int numInlets() const;
		InletPtr inlet(int index);
		const InletPtr inlet(int index) const;
		std::vector<InletPtr> inlets();

		int numOutlets() const;
		OutletPtr outlet(int index);
		const OutletPtr outlet(int index) const;
		std::vector<OutletPtr> outlets();
		
		std::vector<ParameterPtr> parameters();
		
		

		/// Enabled is a node-specific, user adjustable setting. When disabled,
		/// a node should ignore all input and does not produce new output.
		/// step() will not be called
		virtual void setEnabled(bool isEnabled);
		bool isEnabled() const { return mIsEnabled; }
		
		// Functions called by the owning pipeline
		/// Requests the node prepares to start processing. Override this to
		/// implement code to initialize processing. Call this original function
		/// first.
		virtual void startProcessing();
		/// Requests that the node processes one frame of data from its inlets.
		/// Override this function to implement code that performs a single update.
		/// This function may be called
		/// sequentially from different threads (but not concurrently).
		virtual void stepProcessing() = 0;
		/// Requests that the node stops processing data. Override this function to
		/// implement code that concludes processing. Call this original function
		/// first.
		virtual void stopProcessing();
		/// \return true if we are between startProcessing and stopProcessing calls
		/// (even if isEnabled is false)
		bool isProcessing() const { return mIsProcessing; }
		
	protected:
		/// Nodes cannot be directly constructed as they are always
		/// subclassed.
		/// \param className should the the name of the bottom-most derived class
		Node(Params params, std::string className);
		
		/// Factory function to create new instances of a node. Derived types
		/// must implement this for nodes to be able to be created.
		/// \return A new instance of the derived Node type constructed with
		/// the \p params provided.
		virtual NodePtr create(Params params) const = 0;

		/// This function may only be used at construction otherwise a runtime error
		/// will be thrown.
		virtual InletPtr createInlet(Types types, std::string const& name, std::string const& helpText="");
		/// This function may only be used at construction otherwise a runtime error
		/// will be thrown.
		virtual OutletPtr createOutlet(Types types, std::string const& name, std::string const& helpText="");
		/// Create a parameter. A pointer to the parameter is returned which may
		/// be used to customise it.
		/// Parameter effects (callbacks and updates from external sources) only take
		/// effect during a call to updateParameters, which you should do at
		/// the beginning of every step() call (or equivalently frequently if using
		/// NodeThreaded).
		/// The path of the parameter will be the path of the node followed by \p
		/// name.
		/// \param The name of the parameter. This needs to be unique relative to
		/// this node.
		/// \param A pointer to the value that the parameter will be controlling.
		/// \return A pointer to the parameter. This will remain valid for
		/// the lifetime of this node.
		template <typename T>
		Parameter<T>* addParameter(std::string name, T* value);
		/// Updates all parameters, activating callbacks where applicable. Callbacks
		/// run in the same thread as this function. This function is called
		/// before step() within NodeUnthreaded. Within NodeThreaded you
		/// will need to call it yourself each time within your update loop.
		/// \note The values associated with the parameters must not be changed
		/// during a call to this function.
		void updateParameters();
		
		
		

		
		// MARK: Accessors
		Params nodeParams() const;
		/// \param params may be modified by this function to ensure it has
		/// valid values
		void setNodeParams(Params& params);
		
	private:
		std::vector<InletPtr> mInlets;
		std::vector<OutletPtr> mOutlets;
		std::vector<ParameterPtr> mParameters;
		mutable boost::shared_mutex mParametersMutex;
		Params mNodeParams;
		mutable boost::shared_mutex mNodeParamsMutex;
		std::atomic<bool> mIsEnabled;
		std::atomic<bool> mIsProcessing;
		std::atomic<bool> mHasStartEverBeenCalled;
		const std::string mClassName;

		static std::set<std::string> sNamesInUse;
		static boost::mutex sNamesInUseMutex;
	};
	
	typedef std::function<NodePtr (Node::Params)> NodeCreationFunction;
	
	std::ostream& operator<<(std::ostream&, Node const&);
	

	
	template <typename T>
	Parameter<T>* Node::addParameter(std::string name, T* value)
	{
		std::shared_ptr<Parameter<T>> parameter(new Parameter<T>(*this, name, value));
		boost::lock_guard<boost::shared_mutex> lock(mParametersMutex);
		mParameters.push_back(parameter);
		return parameter.get();
	}
}